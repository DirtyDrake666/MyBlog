---
author:
- 潘泓旭
title: 数值分析第一次上机报告
---

**数值计算第一周上机作业**

潘泓旭

修订日期：2024 年 2 月 267 日

问题
====

\(1\)
设计算法找出使用的计算机的机器精度、下溢值和上溢值并编程验证所设计算法的正确性

\(2\) 设计算法计算 $y=x-\sin(x)$，使得有效位的丢失最多 1
位。编程验证所设计算法的正确性

\(3\) 计算积分 $y_n=\int^1_0 x^ne^x \, dx$

\(4\) 考虑递推关系为$x_{n+1}=\frac{13}{3}x_n-\frac{4}{3}x_{n-1}$
分别在初值$x_0=1,x_1=1/3$以及$x_0=1,x_1=4$下的稳定性

算法思路
========

问题 1
------

我们使用 Python 中的 sys
模块来实现机器精度，上溢值和下溢值的实际值的查询。

通过计算 2
的幂次来得到机器精度，上溢值和下溢值的理论值，并与实际值进行比较。上溢
值和下溢值的理论值可以根据定义直接得出形式结果，再计算即可。

问题 2
------

根据精度丢失定理

若 x 和 y 是正的规格化二进制浮点数满足 x \> y, 且
$2^{-q} \leq 1-\frac{y}{x}\leq 2^{-p}$, 则在减法 x - y 中丢失至多 q
个、至少 p 个有效的二进制位。

其中取 $y$ 为 $\sin(x)$, $x$ 为
$x$，则当$1-\frac{\sin(x)}{x}\geqslant \frac{1}{2}$时，有效位的丢失在 1
位; 为此我们求解方程$$1-\frac{\sin(x)}{x}=\frac{1}{2}$$
可以得到零点$x_0\approx 1.89549$，为美观可近似取 2 为分界，在其他情况下
$x$是较小的，我们可以使用$\sin(x)$的 Taylor 展开表示$\sin(x)$的近似值

$$\sin(x)=x-\frac{x^3}{6}+\frac{x^5}{120}+o(x^5)$$

进而用 $\frac{x^3}{6}-\frac{x^5}{120}$ 表示 $x-\sin(x)$ 近似值，研究误差
$$1-\frac{x-\sin(x)}{\frac{x^3}{6}-\frac{x^5}{120}}\geqslant \frac{1}{2}$$
进而由精度丢失定理知有效位丢失在 1 位

**改进**：由于使用的是在 0 处的 Taylor 展开，在距离 0
较远处会有较大误差，为此我们考虑$\sin(x)$在$x_0=\frac{\pi}{2}$
处泰勒展开

$$\sin(x)=1-\frac{1}{2}(x-\frac{\pi}{2})^2+o(x^2)$$

在 (0,1.1) 处使用 0 处的 Taylor 展开，在 (1.1,2)
处使用$\frac{\pi}{2}$处泰勒展开，在其他处直接计算$x-\sin (x)$ 算法如下：

$x-\sin (x)$ $\frac{x^3}{6}-\frac{x^5}{120}$
$x - 1 + \frac{(x - \pi / 2)^2}{2}$ $y \gets F(x)$

问题 3
------

由分部积分法得$$\begin{aligned}
    y_{n+1} &= \left. x^{n+1}e^x \right|_{0}^{1} - \int_{0}^{1} e^x (n+1)x^n \, dx \\
            &= e - (n+1) y_n
\end{aligned}$$ 要分析是否稳定，我们需要分析误差的变化情况。
记$y_n$为$n$次迭代的结果，$y_n^*$为精确值，定义其相对误差为
$\varepsilon_n = \frac{|y_n - y_n^*|}{|y_n^*|}$
则只需要分析$\varepsilon_n$的变化情况。算法如下：

$n \geqslant 0$ $y_n, \varepsilon_n$ $0$ $\mathrm{e} -nF(n-1)$
$y_n \gets F(n)$ $\varepsilon_n \gets \frac{|y_n - y_n^*|}{|y_n^*|}$

问题 4
------

首先验证$x_0 = 1, x_1 = \frac{1}{3}$时，算法不稳定。

根据原递推公式，由数学归纳法不难得出精确值$x_n^* = \frac{1}{3^n}$.$$x_n^*= \frac{13}{3}3^{n-1} - \frac{4}{3}3^{n-2}=3^{n}$$

$n$次迭代的结果算法如下：

$n \geqslant 0$ $x_n, \varepsilon_n$ $1$ $\frac{1}{3}$
$\frac{13}{3}F(n-1) - \frac{4}{3}F(n-2)$ $x_n \gets F(n)$
$\varepsilon_n \gets \frac{|x_n - x_n^*|}{|x_n^*|}$

若将初值改为$x_0 = 1, x_1 = 4$, 同理归纳可以得到$x_n^* = 4^n$.

可以用类似的算法分析相对误差的变化情况。可以判断算法是否稳定。

$n \geqslant 0$ $x_n, \varepsilon_n$ $1$ $3$
$\frac{13}{3}F(n-1) - \frac{4}{3}F(n-2)$ $x_n \gets F(n)$
$\varepsilon_n \gets \frac{|x_n - x_n^*|}{|x_n^*|}$

结果分析
========

问题 1
------

根据输出的结果有：

机器实际精度 = 2.220446049250313$\times 10^{-16}$

上溢值实际值 = 1.7976931348623157$\times 10^{308}$

下溢值实际值 = 2.2250738585072014$\times 10^{-308}$

理论上：

机器理论精度 = 2.220446049250313 $\times 10^{-16}$

上溢值理论值 = 1.7976931348623157 $\times 10^{308}$

下溢值理论值 = 2.2250738585072014 $\times 10^{-308}$

经对比，实际值与理论值一致

问题 2
------

可以发现，由于使用的是$\sin(x)$在$x_0=0$处的展开，在$x$靠近 0
时误差更小，为此，我们可以使用$\sin(x)$在$x_0=\pi/2$处的展开在 2
附近获得更好的逼近效果

问题 3
------

由此我们可以发现相对误差呈指数级增长，该算法不稳定

问题 4
------

从上表可以看出，对于初值条件
1，当$n$较小时，相对误差较小，随着$n$的增大，相对误差逐渐增大。
可见如果初值条件为情况 1, 则算法不稳定。

从下表可以看出，对于初值条件
2，当$n$较小时，相对误差较小，随着$n$的增大，相对误差基本保持不变
.可见如果初值条件为情况 2, 则算法稳定。

结论
====

问题 1
------

该算法较简单，只是调用了 Python
中的一个库函数。具有一定的语言局限性，如在 C++ 语言中没有类似的包

问题 2 
------

该算法使用的是 Taylor
展开逼近，在一定的范围内误差小。如果需要更大的精度，可以增加 Taylor
展开项数；由于使用的是$\sin(x)$在$x_0=0$处的展开，在$x$靠近 0
时误差更小，而 x 较大时误差显著，为此我们可以使用在另一点处的展开。
同样地，可以通过增加 Taylor 展开项数以获得更高精度，

但是有的函数并不能使用泰勒展开，如不光滑或收敛慢或不具有足够导数；其次，求导繁琐以及逼近范围有限也是问题；
Taylor
展开是局部的，不能捕捉到函数的全局行为，尤其是在展开点附近存在奇点或其他特殊点的情况下；
且在调用$\pi$的时候会带来新的舍入误差，为此我们选择 1.1
作为分界点以减小其带来的影响。

问题 3
------

该算法使用 scripy
库的函数计算积分精确值，用以与递归算法得到的结果进行比较，
可以得到算法不稳定的结论。这也与理论计算一致$$|\epsilon_{n+1}|=(n+1)|\epsilon_n|\\
    \Rightarrow |\epsilon_{n+1}|=(n+1)!|\epsilon_0|$$

但是，这里 Python
内置的函数通常使用数值积分方法来计算定积分，仍然与真实值有一定差距。
且可能会受到数值精度的限制，特别是在处理复杂函数或积分区间较大的情况下。同时递归计算
函数积分的方法不具备一般性，即许多函数并没有递推关系式，且计算较大的$n$时会出现数值或者内存溢出的情况。

问题 4
------

对第一个初值，该算法使用递推关系式计算$x_n$的值，使用归纳法得到理论值，两者比较可以得到算法不稳定的结论。
这也与理论计算一致，由特征方程可以计算$$|\epsilon_n|\thickapprox (\frac{13}{3})^n|\epsilon_0|  \tag{$\frac{1}{3^n}$可以忽略}$$

在每一步都有截断误差的积累，导致了指数增长的相对误差
对第二个初值，由于每次计算后的值都是整数，截断误差较小，不会有太大误差，算法是稳定的

附录：程序代码
==============

``` {.python .numberLines frame="single" linenos="true" bgcolor="bg"}
    import sys

    eps=sys.float_info.epsilon
    print("epsilon = ", eps)    
    max=sys.float_info.max   
    print("max = ", max)   
    min=sys.float_info.min  
    print("min = ",min) 
    print("机器精度理论值为 ", 2**(-52))
    print("上溢值理论值为 ", 2**(1023)*(2-2**(-52)))
    print("下溢值理论值为 ", 2**(-1022))
```

``` {.python .numberLines frame="single" linenos="true" bgcolor="bg"}
    import math

def F(x):
    if x < 0:
        print("Error!")
    if x<2:
        return (x**3)/6-(x**5)/120
    else:
        return x-math.sin(x)
def G(x):
    if x<1.1 or x>2:
        return F(x)
    else:
        return x - 1 + (x - math.pi / 2) ** 2 / 2
```

``` {.python .numberLines frame="single" linenos="true" bgcolor="bg"}
    import math

def F(n):
    if(n==0):
        return 0
    else:
        return math.e-n*F(n-1)
```

``` {.python .numberLines frame="single" linenos="true" bgcolor="bg"}
    import math
x0 = 1.0
x1 = 1/3 #replace with 4 in another case
def f(n, x0, x1):
    if n == 0:
        return x0
    elif n == 1:
        return x1
    else:
        return 13*f(n-1,x0,x1)/3.0-4*f(n-2,x0,x1)/3.0
```

附录：结果输出
==============

问题 2 测试数据
---------------

   $x$           $y^*$                 $\bar{y}$                  $y$
  ----- ----------------------- ----------------------- -----------------------
   0.1   0.0001665833333333334   0.0001665833333333334   0.0001665833531718508
   0.2   0.001330666666666667    0.001330666666666667    0.0013306692049387947
   0.3   0.004479750000000002    0.004479750000000002    0.004479793338660443
   0.4   0.010581333333333337    0.010581333333333337     0.0105816576913495
   0.5   0.020572916666666666    0.020572916666666666    0.020574461395796995
   0.6   0.035351999999999995    0.035351999999999995    0.035357526604964606
   0.7    0.05576608333333332     0.05576608333333332     0.05578231276230894
   0.8    0.08260266666666666     0.08260266666666666     0.08264390910047725
   0.9    0.11657924999999995     0.12498385602076281     0.11667309037251661
   1.0    0.15833333333333327     0.16290422334127314     0.1585290151921035
   1.1    0.20841241666666657     0.21082459066178344     0.20879263993856456
   1.2         0.267264           0.2687449579822938      0.26796091403277367
   1.3    0.33522558333333335     0.33666532530280424     0.3364418145828071
   1.4    0.41251466666666675     0.4145856926233147      0.4145502700115399
   1.5    0.49921875000000016     0.5025060599438251      0.5025050133959458
   1.6    0.5952853333333337      0.6004264272643356      0.6004263969584952
   1.7    0.7005119166666671      0.7083467945848461      0.7083351895475318
   1.8    0.8145360000000006      0.8262671619053565      0.8261523691218055
   1.9    0.9368250833333341       0.954187529225867      0.9536999123125863
   2.0     1.090702573174319       1.090702573174319       1.090702573174319

  : 问题 2 测试数据

问题 3 测试数据
---------------

::: {#tab:q1}
   $n$         $\epsilon$
  ----- ------------------------
    1      1.718281828459045
    2      4.7844223823546645
    3      18.297880669823066
    4      88.77400974392317
    5      521.2185417317049
    6      3589.2613883379977
    7      28348.356307980615
    8      252517.6272394183
    9      2503855.114876289
   10      27347630.06205966
   11      326199132\.1212808
   12      4218657280.839123
   13       58795563051.4308
   14       878451924638.809
   15      14006138513234.771
   16      237363260734919.38
   17      4260613368769276.5
   18    8.074788021788658e+16
   19    1.6112726008017964e+18

  : 问题 3 测试数据
:::

问题 4 测试数据
---------------

::: {#tab:q2}
   $n$         $\epsilon$              $\epsilon^*$
  ----- ------------------------ ------------------------
    2    4.996003610813204e-16    1.1102230246251565e-16
    3    5.995204332975847e-15    1.1102230246251565e-16
    4    7.194245199571016e-14    1.1102230246251565e-16
    5    8.620448105345349e-13    1.1102230246251565e-16
    6    1.034343118967718e-11    1.1102230246251565e-16
    7    1.2411939591351276e-10   1.1102230246251565e-16
    8    1.4894318617808466e-09   1.1102230246251565e-16
    9    1.787318367514212e-08    1.1102230246251565e-16
   10    2.144782049019686e-07    1.1102230246251565e-16
   11     2.57373845957387e-06    1.1102230246251565e-16
   12    3.088486151679957e-05    1.1102230246251565e-16
   13    0.00037061833820395813   1.1102230246251565e-16
   14    0.0044474200584499034    1.1102230246251565e-16
   15     0.05336904070140074     1.1102230246251565e-16
   16      0.6404284884168117     1.1102230246251565e-16
   17      7.685141861001745      1.1102230246251565e-16
   18      92.22170233202095      1.1102230246251565e-16
   19      1106.6604279842516     1.1102230246251565e-16
   20      13279.925135811018     1.1102230246251565e-16
   21      159359.1016297322      1.1102230246251565e-16
   22      1912309.2195567864     1.1102230246251565e-16
   23      22947710.634681445     1.1102230246251565e-16
   24      275372527\.6161773     1.1102230246251565e-16
   25      3304470331.3941283     1.1102230246251565e-16
   26      39653643976.729546     1.1102230246251565e-16
   27      475843727720.75446     1.1102230246251565e-16
   28      5710124732649.054      1.1102230246251565e-16
   29      68521496791788.64      1.1102230246251565e-16

  : 问题 4 测试数据
:::